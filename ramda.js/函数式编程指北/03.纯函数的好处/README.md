# 03. 纯函数的好处


## 3.1 什么是纯函数

纯函数，是实践函数式编程范式的一项基础规则。

> 纯函数：相同的输入，永远会得到相同的输出；以及函数的执行需要“无副作用”。

此处无副作用的含义就是，在函数执行的过程中，不能对外界的环境做出改变。

比如说数组上的方法 `slice` 与 `splice`。 `slice` 不会改变元数组，它就是纯的。而 `splice` 会对原数组产生改变，它就是不纯的。

不纯的函数中，返回的结果依赖于函数外部的变量 `minimum` ，当此变量发生变化的时候，对于checkAge函数来说，相同的输入便不能得到相同的返回结果。

**无副作用**
```javascript
// 不纯的
var minimum = 21;

var checkAge = function(age) {
  return age >= minimum;
};


// 纯的
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```
## 3.2 副作用

> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。

- 更改文件系统
- 往数据库插入记录
- 发送一个 http 请求
- 可变数据
- 打印/log
- 获取用户输入
- DOM 查询
- 访问系统状态

概括来讲，只要是跟函数外部环境发生的交互就都是副作用

函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。

## 3.3 为何要坚持“纯函数”

这里书上讲得比较好 

[八年级数学](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E8%BF%BD%E6%B1%82%E2%80%9C%E7%BA%AF%E2%80%9D%E7%9A%84%E7%90%86%E7%94%B1)

### 3.3.1 “纯函数”的线性意义

简单来讲，如果一个函数是一个“纯函数”，那么它的一个输入就对应着唯一的一个输出（不同的输入可能会对应相同的输出) ，
这种情况下，输入与输出的关系，甚至能整理成一个简单的映射表。
如此，输入与输出的关系就能够简化为一个简单的线性关系，这么做的意义在于提高代码的逻辑表达能力 —— 二维、线性的关系总是令人容易理解的

![](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/images/fn_graph.png)

这种关系表现在代码上，能够让每一次输入得到固定的输出，我们能够写出符合线性思维的代码。

如果我们舍弃这个特性，也就是说在一个函数中封装复杂的代码逻辑，其中有n多个条件判断，并且还对外部的变量进行了依赖。
想一想在阅读源码的时候会有多麻烦，需要不断在函数内部实现与外部依赖之间跳转以查看代码；需要监控对外部环境是否有进行什么改变；
需要监控对外部环境变量的改变会不会对其他地方的函数调用造成了影响。

在上述情况下，理解程序就不再是一个简单的线性行为，需要多个地方综合考虑。
而使用纯函数的时候，我们可以结合良好的命名，将函数内部的实现抽象理解，不用去管函数的内部实现。在业务逻辑聚合的地方完成对代码的整体理解。

### 3.3.2 可缓存性

因为一个输入对应一个输出，可以将输入与输出制作出一个映射表进行缓存，在重复输入的时候，免除计算，返回缓存的内容。

```javascript
var squareNumber  = memoize(function(x){ return x*x; });

squareNumber(4);
//=> 16

squareNumber(4); // 从缓存中读取输入值为 4 的结果
//=> 16

squareNumber(5);
//=> 25

squareNumber(5); // 从缓存中读取输入值为 5 的结果
//=> 25

var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};

```
利用可缓存性，也能将一个不纯的函数转换为纯函数。

```javascript
var pureHttpCall = memoize(function(url, params){
  return function() { return $.getJSON(url, params); }
});
```
memorize 函数的封装很有意思，它只是起到了一个缓存输入与输出映射的能力。而具体是怎样的映射行为则是开放的，可自定义的。
并且在执行调用的时候，对于调用参数的传入与调用函数内部逻辑的实现，也不用跳转到memorize内部去查看。
属于封装之后就能长期使用的。

这里“通过延迟执行让函数变纯”的说法，参考memoize来理解。
memoize 可以理解为一个函数生成器，不仅它自身是一个纯函数，通过它生成的函数也是纯函数。
这样就可以将原本需要存在于外界环境中的某些变量（此处为cache)，封装到生成器函数内部。



### 3.3.3 可移植性/子文档性

**子文档性**

纯函数自给自足，所有的依赖都来自参数。因为依赖明确，所以更容易观察和理解。

纯函数对与依赖必须诚实，这样我们才能根据参数传递与函数命名，直观地阅读到他的目的。
做到这点，需要将函数中对外部函数的依赖放到参数中，然后再通过延迟执行或者curry的方法，拆分参数或进行其他操作。

**可移植性**
将所有的依赖都放在参数上，那么只要能够构造出所依赖的数据的地方都可以使用封装好的函数。
甚至于，可以将函数序列化之后通过socket传递，到别的地方使用。

### 3.3.4 可测试性

纯函数让测试更加容易。我们并不需要去根据函数内部的依赖去伪造一个环境，只需要构造好一个何时的参数即可。

社区有一些新的测试工具，能够帮助我们自动生成输入并断言输出。

QuickCheck 

### 3.3.5 合理性

很多人相信使用纯函数最大的好处是引用透明性。如果一段代码可以替换成它执行所得的结果，
而且是在不改变整个程序行为的前提下替换的，那我们就说这段代码是引用透明的。

分析代码的时候可以使用一种“等式推导”的方式。详细描述参见原文

[追求“纯”的理由 - 合理性](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html#%E6%80%BB%E7%BB%93)

### 3.3.6 并行代码

可以并行运行任意纯函数。因为纯函数不需要访问共享的内存，而且根据定义，纯函数也不会因为副作用而进入竞争态。

不过处于非纯函数的复杂度的考虑，当前主流观点还是避免使用这种并行。







